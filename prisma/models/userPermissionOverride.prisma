model UserPermissionOverride {
  idUser       String  @db.VarChar(25)
  idPermission Int     @db.Integer
  allow        Boolean @db.Boolean // true = pÅ™idÃ¡ oprÃ¡vnÄ›nÃ­, false = zakÃ¡Å¾e

  user       User       @relation(fields: [idUser], references: [idUser])
  permission Permission @relation(fields: [idPermission], references: [idPermission])

  @@id([idUser, idPermission])
  @@schema("user")
}

// | IdUser (uÅ¾ivatel) | IdPermission    | Allow |
// | ----------------- | --------------- | ----- |
// | `user123`         | 4 (`VIEW_LOGS`) | true  |

// Tvoje tabulka UserPermissionOverride pÅ™edstavuje ruÄnÃ­ Ãºpravu oprÃ¡vnÄ›nÃ­ pro konkrÃ©tnÃ­ho uÅ¾ivatele â€“ tedy vÃ½jimky vÅ¯Äi bÄ›Å¾nÃ©mu oprÃ¡vnÄ›nÃ­ z rolÃ­. To je velmi uÅ¾iteÄnÃ½ nÃ¡vrh. Tady je, jak bys ji mÄ›l ideÃ¡lnÄ› pouÅ¾Ã­vat:

// Co znamenÃ¡ Allow?
// true: uÅ¾ivatel mÃ¡ danÃ© oprÃ¡vnÄ›nÃ­, i kdyby ho nemÄ›l pÅ™es roli.

// false: uÅ¾ivateli se odebere oprÃ¡vnÄ›nÃ­, i kdyby ho mÄ›l pÅ™es roli.

// Jak naÄÃ­tat oprÃ¡vnÄ›nÃ­ uÅ¾ivatele
// ZÃ­skat oprÃ¡vnÄ›nÃ­ z rolÃ­ (standardnÃ­ pÅ™Ã­stup):

// ts
// ZkopÃ­rovat
// Upravit
// const rolePermissions = await prisma.permission.findMany({
//   where: {
//     UserRoleType: {
//       some: {
//         UserRole: {
//           some: {
//             IdUser: userId,
//           },
//         },
//       },
//     },
//   },
// });
// ZÃ­skat pÅ™epsanÃ¡ oprÃ¡vnÄ›nÃ­ z tabulky UserPermissionOverride:

// ts
// ZkopÃ­rovat
// Upravit
// const overrides = await prisma.userPermissionOverride.findMany({
//   where: {
//     IdUser: userId,
//   },
// });
// Kombinovat vÃ½sledky:

// NapÅ™Ã­klad v JavaScriptu:

// ts
// ZkopÃ­rovat
// Upravit
// const permissionMap = new Map<number, boolean>();

// // NaplnÃ­me oprÃ¡vnÄ›nÃ­ z rolÃ­ (vÅ¡echna jako true)
// for (const perm of rolePermissions) {
//   permissionMap.set(perm.IdPermission, true);
// }

// // Aplikujeme override â€“ pÅ™epÃ­Å¡e pÅ™edchozÃ­ stav
// for (const override of overrides) {
//   permissionMap.set(override.IdPermission, override.Allow);
// }

// // VÃ½sledek: jen ty oprÃ¡vnÄ›nÃ­, kterÃ¡ majÃ­ hodnotu true
// const finalPermissions = Array.from(permissionMap.entries())
//   .filter(([_, allow]) => allow)
//   .map(([id]) => id);
// ProÄ je to dÅ¯leÅ¾itÃ©?
// UmoÅ¾ÅˆujeÅ¡ sprÃ¡vci systÃ©mu jemnÄ› doladit oprÃ¡vnÄ›nÃ­ pro jednotlivce.

// VÃ½bornÃ© pro vÃ½jimky typu: â€Tento uÅ¾ivatel mÃ¡ roli 'Redaktor', ale nesmÃ­ mazat ÄlÃ¡nky.â€œ

// Indexy pro vÃ½kon
// PÅ™idej si index na IdUser, pokud Äasto hledÃ¡Å¡ podle uÅ¾ivatele:

// prisma
// ZkopÃ­rovat
// Upravit
// @@index([IdUser])
// ShrnutÃ­
// Tabulku UserPermissionOverride pouÅ¾ij jako vrstvu navÃ­c, kterÃ¡:

// pÅ™idÃ¡vÃ¡ oprÃ¡vnÄ›nÃ­, kterÃ¡ by jinak chybÄ›la,

// odebÃ­rÃ¡ oprÃ¡vnÄ›nÃ­, kterÃ¡ by jinak existovala,

// pÅ™episuje logiku z rolÃ­.

// Takto zajistÃ­Å¡ maximÃ¡lnÃ­ flexibilitu pÅ™i Å™Ã­zenÃ­ pÅ™Ã­stupovÃ½ch prÃ¡v.

// Å˜ekl/a jsi:
// Jak a kdy bych mÄ›l do tÃ¡to tabulky pÅ™idÃ¡vat data?

// ChatGPT Å™ekl:
// Do tabulky UserPermissionOverride bys mÄ›l pÅ™idÃ¡vat (nebo aktualizovat) zÃ¡znamy pouze tehdy, kdyÅ¾ chceÅ¡ ruÄnÄ› upravit oprÃ¡vnÄ›nÃ­ konkrÃ©tnÃ­ho uÅ¾ivatele â€“ mimo to, co mÃ¡ z rolÃ­. NÃ­Å¾e ti rozepÃ­Å¡u kdy, proÄ a jak s touto tabulkou pracovat:

// Kdy pÅ™idÃ¡vat do UserPermissionOverride?
// PÅ™idÃ¡nÃ­ oprÃ¡vnÄ›nÃ­ mimo roli
// NapÅ™. UÅ¾ivatel mÃ¡ roli â€Redaktorâ€œ, ale potÅ™ebuje i pÅ™Ã­stup k administraci.

// IdPermission = "admin_access" â†’ Allow = true

// OdebrÃ¡nÃ­ oprÃ¡vnÄ›nÃ­ pÅ™idÄ›lenÃ©ho rolÃ­
// NapÅ™. UÅ¾ivatel mÃ¡ roli â€AdministrÃ¡torâ€œ, ale nesmÃ­ mazat uÅ¾ivatele.

// IdPermission = "delete_users" â†’ Allow = false

// ZmÄ›na existujÃ­cÃ­ho override (napÅ™. pÅ™es administraÄnÃ­ UI)
// NapÅ™. sprÃ¡vce systÃ©mu ruÄnÄ› upravÃ­ oprÃ¡vnÄ›nÃ­ konkrÃ©tnÃ­ho uÅ¾ivatele.

// ğŸ›  Jak to uklÃ¡dat?
// 1. PÅ™idÃ¡nÃ­ zÃ¡znamu
// ts
// ZkopÃ­rovat
// Upravit
// await prisma.userPermissionOverride.create({
//   data: {
//     IdUser: userId,
//     IdPermission: permissionId,
//     Allow: true, // nebo false podle potÅ™eby
//   },
// });
// 2. Aktualizace override (napÅ™. zmÄ›na Allow)
// ts
// ZkopÃ­rovat
// Upravit
// await prisma.userPermissionOverride.upsert({
//   where: {
//     IdUser_IdPermission: {
//       IdUser: userId,
//       IdPermission: permissionId,
//     },
//   },
//   update: {
//     Allow: true, // nebo false
//   },
//   create: {
//     IdUser: userId,
//     IdPermission: permissionId,
//     Allow: true, // nebo false
//   },
// });
// DÃ­ky tomu, Å¾e mÃ¡Å¡ @@id([IdUser, IdPermission]), mÅ¯Å¾eÅ¡ pouÅ¾Ã­t upsert.

// Kdy nepÅ™idÃ¡vat zÃ¡znamy?
// Pokud se uÅ¾ivatel Å™adÃ­ do sprÃ¡vnÃ½ch rolÃ­ a vÅ¡e funguje podle oÄekÃ¡vÃ¡nÃ­, nenÃ­ potÅ™eba mÃ­t zÃ¡znamy v tÃ©to tabulce.

// Je dobrÃ© udrÅ¾ovat UserPermissionOverride co nejmenÅ¡Ã­, protoÅ¾e slouÅ¾Ã­ jen jako vÃ½jimka, ne jako primÃ¡rnÃ­ zdroj oprÃ¡vnÄ›nÃ­.

// TypickÃ½ pÅ™Ã­pad pouÅ¾itÃ­ v administraci
// Admin v UI oznaÄÃ­ checkboxem, Å¾e chce uÅ¾ivateli pÅ™idat/odebrat urÄitÃ© oprÃ¡vnÄ›nÃ­.

// Backend zavolÃ¡ upsert pro kaÅ¾dÃ½ override (true/false).

// KdyÅ¾ chceÅ¡ zruÅ¡it override, jednoduÅ¡e zÃ¡znam smaÅ¾:

// ts
// ZkopÃ­rovat
// Upravit
// await prisma.userPermissionOverride.delete({
//   where: {
//     IdUser_IdPermission: {
//       IdUser: userId,
//       IdPermission: permissionId,
//     },
//   },
// });
//  ShrnutÃ­
// Akce	Co udÄ›lÃ¡Å¡ v tabulce UserPermissionOverride?
// PÅ™idat oprÃ¡vnÄ›nÃ­ mimo roli	Allow: true
// ZakÃ¡zat oprÃ¡vnÄ›nÃ­ z role	Allow: false
// VrÃ¡tit stav do pÅ¯vodnÃ­ho (z role)	ZÃ¡znam smazat

// TÃ­mto zpÅ¯sobem zÅ¯stane tabulka ÄistÃ¡ a bude pÅ™esnÄ› plnit roli vÃ½jimek, kterÃ© pÅ™episujÃ­ bÄ›Å¾nÃ¡ pravidla z rolÃ­.
